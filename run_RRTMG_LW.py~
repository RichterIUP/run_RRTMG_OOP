#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed Jul 15 14:09:11 2020

@author: philipp
"""

import os
import subprocess
import pandas as pd
import netCDF4 as nc
import datetime as dt
import numpy as np

#path_home = os.getenv("HOME") + "/Code/RRTMG"
SRC_RRTMG_LW = "model/RRTMG_LW/build/rrtmg_lw_v5.00_linux_pgi"#path_home + '/models/rrtmg_lw_v5.00_linux_ifort'
SRC_RRTMG_SW = "model/RRTMG_SW/build/rrtmg_sw_v5.00_linux_pgi_aerosol"#path_home + '/models/rrtmg_sw_v5.00_linux_pgi'
KEYS_SW = ['LEVEL', 'PRESSURE', 'UPWARD FLUX', 'DIFDOWN FLUX', 'DIRDOWN FLUX', 'DOWNWARD FLUX', 'NET FLUX', 'HEATING RATE']
KEYS_LW = ['LEVEL', 'PRESSURE', 'UPWARD FLUX', 'DOWNWARD FLUX', 'NET FLUX', 'HEATING RATE']
ALBEDO = 0.6
SZA = 75.0
GLOBAL_ATM = ""
GLOBAL_AEROSOL = ""
GLOBAL_ALB = ""

HEIGHT_PROF =  np.array([0.018,0.06,0.1,0.15,0.2,0.25,0.3,0.35,0.36,0.37,0.38,0.39,0.4,0.45,0.5,0.52,0.57,0.62,0.72,0.78,0.81,0.86,0.92,1.1,1.25,1.4,1.6,1.8,2.0,2.2,2.4,2.6,2.8,3.0,3.2,3.6,3.8,4.0,4.2,4.4,4.7,5.0,5.3,5.6,5.9,6.2,6.5,6.8,7.1,7.4,7.7,8.0,8.4,8.8,9.2,9.6,10.0,10.5,11.0,11.5,12.0,12.5,13.0,14.0,15.0,16.0,17.0,19.0,21.0,23.0,25.0,28.0,30.0,32.0,33.0,34.0,35.0,36.0,37.0,38.0,39.0,40.0,41.0,42.0,43.0,44.0,45.0,52.5,54.375,55.3125,56.25,58.125,60.0
])

T_PROF = np.array([271.50708911422845,271.03667040322915,270.6626152418768,270.2879168961242,269.9830293302528,269.7770680845916,269.7441660608937,269.858132177665,269.91185784064237,269.9655835036197,270.01930916659705,270.09582355911687,270.2547797796419,271.1136859435683,272.59662232286445,273.20636586439736,274.75992879874235,275.6938568365813,276.39240400579183,276.51649734244086,276.5759074202502,276.64935053199156,276.7259224806989,276.33672557002967,275.78987811295525,275.1579506228912,274.36894916123333,273.58885173421095,272.7802461738972,271.93466229148373,271.0392155091905,270.06449680039077,269.0314340716875,268.00713550812185,267.01302067561437,264.91030222720667,263.7810248763359,262.5771317465649,261.2757357510189,259.92575409336234,257.8060201759259,255.57550303025027,253.28146639558645,250.95127157925074,248.55837776497063,246.09413390586246,243.62695296020038,241.29868797497787,239.07974975316984,236.82747919284554,234.43646885039163,231.93280865797718,228.5026875640205,225.08497253469534,221.63922520290686,218.2366526922021,214.94315980421564,211.78394406647806,213.12386158315178,217.92401113989638,220.3615166873977,221.42032867710634,222.1864952066954,223.2317834926549,223.83229581511554,224.19966430993017,225.0543402729211,226.1672111359559,227.44887364841736,228.23268350572476,228.07716766180116,229.6018983810182,233.58349996499533,236.7569454834424,239.4809549451332,242.45190916310324,245.91815379932015,249.72197046787502,253.47844963832847,256.58198482336473,259.47925670356915,263.15855539212885,267.670423200619,271.7091572944358,273.8622213425949,275.25525637121956,276.1575323276674,280.3199030993897,277.79223460818645,276.07404116155516,274.05261688873424,269.4609475976165,263.9330253926323
])
PRESS_PROF = np.array([1021.9173907934955,1016.5229182061788,1011.4021968967446,1005.0328165026843,998.6915749748605,992.3871514005505,986.1197891429175,979.8920865057239,978.652636030568,977.4131855554122,976.1737350802562,974.9367148338273,973.7084863236092,967.5745065603885,961.5102311524697,959.1064262712749,953.1355237617904,947.2408938325844,935.5744032874161,928.6616242377168,925.2147613796303,919.5197359011097,912.7081914305975,892.6281499404646,876.1776351864843,860.0095223216397,838.8798998527305,818.1818359059708,797.9242109419773,778.1339406449894,758.7767490903425,739.8295645905844,721.2786521868708,703.1478963807223,685.4242526163164,651.0907167309028,634.4418400122138,618.1348171114504,602.2628056658021,586.6856876061181,563.9111437819113,541.8378664325705,520.4425956636353,499.7064641499852,479.61157252867883,460.1391115332559,441.2727939516129,423.0046283214435,405.33039891615357,388.2390413075806,371.71067162343786,355.7233064163681,335.2536745247175,315.66123127708113,296.90591409733224,279.0670799932431,261.9857245662078,241.86250337340877,223.17397369021688,206.1463093264249,190.737065502455,176.57719228231977,163.46834431904645,140.27851087560697,120.43694393682522,103.43508484541161,88.88272974726365,65.74944503575053,48.69981857915514,36.13728486696844,26.836079270724323,17.1984557689771,12.833052276285025,9.614179229348002,8.34528988699211,7.252164740378742,6.312806328707888,5.506969053876519,4.815126517784196,4.218715204770662,3.701916306617308,3.2525949839195727,2.860321146310072,2.521505845730133,2.2335152449510076,1.9754435077251806,1.7424527486506334,0.7103162155106162,0.5669216390052725,0.5040939800008049,0.4512231707977518,0.35762198117274907,0.2794673240941852
])

HEIGHT_PROF = HEIGHT_PROF[:-19]
T_PROF = T_PROF[:-19]
PRESS_PROF = PRESS_PROF[:-19]

def create_cloud_rrtmg(lay_liq, lay_ice, cwp, rliq, rice, fice, homogenous, clt):     
    # =============================================================================
    #  RECORD C1.1
    # 	
    #       INFLAG, ICEFLAG, LIQFLAG
    # 
    #            5       10       15
    # 
    #       4X, I1,  4X, I1,  4X, I1
    # 
    # 
    #       Note:  ICEFLAG and LIQFLAG are required only if INFLAG = 2.
    # 
    #             INFLAG = 0 direct specification of optical depths of clouds;
    #                        cloud fraction and cloud optical depth (gray), single scattering albedo,
    # 		       and N-str moments of the phase function
    # 
    #                    = 2 calculation of separate ice and liquid cloud optical depths, with
    #                        parameterizations determined by values of ICEFLAG and LIQFLAG. 
    #                        Cloud fraction, cloud water path, cloud ice fraction, and
    #                        effective ice radius are input for each cloudy layer for all 
    #                        parameterizations.  If LIQFLAG = 1, effective liquid droplet radius
    #                        is also needed.  If ICEFLAG = 1, generalized effective size is
    # 		       is also needed.
    INFLAG = 2
    # 
    #             ICEFLAG = 0 inactive
    #                     = 1 the optical depths (non-gray) due to ice clouds are computed as closely as
    #                         possible to the method in E.E. Ebert and J.A. Curry, JGR, 97, 3831-3836 (1992).
    #                     = 2 the optical properties are computed by a method based on the parameterization
    #                         of spherical ice particles in the RT code, STREAMER v3.0 (Reference: 
    #                         Key. J., Streamer User's Guide, Cooperative Institute for
    #                         Meteorological Satellite Studies, 2001, 96 pp.).
    #                     = 3 the optical depths are computed by a method based on the parameterization
    # 			of ice clouds due to Q. Fu, J. Clim., 9, 2058 (1996).
    ICEFLAG = 1
    # 
    #             LIQFLAG = 0 inactive
    #                     = 1 the optical depths (non-gray) due to water clouds are computed by a method
    #                         based on the parameterization of water clouds due to Y.X. Hu and K. Stamnes,
    #                         J. Clim., 6, 728-742 (1993).
    LIQFLAG = 1
    #                        
    # 	     These methods are further detailed in the comments in the file 'rrtmg_sw_cldprop.F90'
    #              and the module 'rrtmg_sw_susrtop.F90'.
    # 
    RECORD_C1_1  = 4 * " " + "{:1d}".format(INFLAG)
    RECORD_C1_1 += 4 * " " + "{:1d}".format(ICEFLAG)
    RECORD_C1_1 += 4 * " " + "{:1d}".format(LIQFLAG)

    #  RECORD C1.3  (one record for each cloudy layer, INFLAG = 2)
    # 
    #       TESTCHAR,    LAY, CLDFRAC,   TAUCLD or CWP, FRACICE, EFFSIZEICE, EFFSIZELIQ
    # 
    #              1,    3-5,    6-15,           16-25,   26-35,     36-45,     46-55
    # 
    #             A1, 1X, I3,   E10.5,           E10.5,   E10.5,     E10.5,     E10.5
    # 
    # 
    #             TESTCHAR   control character -- if equal to '%', cloud input processing
    #                        is terminated
    # 
    #             LAY        layer number of cloudy layer.  The layer numbering refers to the
    #                        ordering for the upward radiative transfer, i.e. botton to top.
    #                        For IATM = 0 (Record 1.2), each layer's number is equal to the  
    #                        position of its Record 2.1.1 in the grouping of these records.
    #                        For example, the second Record 2.1.1 occurring after Record 2.1
    #                        corresponds to the second layer.  For IATM = 1 (Record 1.2) and 
    #                        IBMAX > 0 (Record 3.1), layer n corresponds to the region between 
    #                        altitudes n and n+1 in the list of layer boundaries in Record 3.3B.  
    #                        For IATM = 1 (Record 1.2) and IBMAX = 0 (Record 3.1), the layer 
    #                        numbers can be determined by running RRTM for the cloudless case
    #                        and examining the TAPE6 output from this run.
    #                        
    #             CLDFRAC    cloud fraction for the layer.
    # 
    #             TAUCLD     (INFLAG = 0 only) total (ice and water) optical depth for the layer
    #      or     CWP        (INFLAG > 0) cloud water path for the layer (g/m2)
    # 
    #             FRACICE    (INFLAG = 2) fraction of the layer's cloud water path in the form
    #                        of ice particles  
    # 
    #             EFFSIZEICE (INFLAG = 2 and ICEFLAG = 1) Effective radius of spherical  
    # 	               ice crystals with equivalent projected area to hexagonal ice particles
    # 	               following Ebert and Curry (1992).
    # 	               Valid sizes are 13.0 - 130.0 microns. 
    #                   
    #                        (INFLAG = 2 and ICEFLAG = 2) Effective radius of spherical  
    # 	               ice crystals, re (see STREAMER manual for definition of this parameter)
    # 	               Valid sizes are 5.0 - 131.0 microns. 
    #                   
    #                        (INFLAG = 2 and ICEFLAG = 3) Generalized effective size of hexagonal
    # 	               ice crystals, dge (see Q. Fu, 1996, for definition of this parameter)
    # 	               Valid sizes are 5.0 - 140.0 microns.  
    # 
    # 		       NOTE: The size descriptions for effective radius and generalized effective
    # 		       size are NOT equivalent.  See the particular references for the appropriate 
    # 		       definition.
    # 
    #             EFFSIZELIQ (INFLAG = 2 and LIQFLAG = 1) Liquid droplet effective radius, re (microns) 
    #                        Valid sizes are 2.5 - 60.0 microns.
    CLDFRAC = clt
    FRACICE = fice
    EFFSIZEICE = rice
    EFFSIZELIQ = rliq
    RECORD_C1_3 = ""
    CWP = cwp
    ii = 0
    
    for lay in list(np.union1d(lay_liq, lay_ice)):
        RECORD_C1_3 += " "
        RECORD_C1_3 += 1 * " " + "{:3d}".format(lay)
        RECORD_C1_3 += "{:>10.5f}".format(CLDFRAC[ii])
        if not homogenous:
            RECORD_C1_3 += "{:>10.5f}".format(CWP[ii])
            RECORD_C1_3 += "{:>10.5f}".format(FRACICE[ii])
            RECORD_C1_3 += "{:>10.5f}".format(EFFSIZEICE[ii])
            RECORD_C1_3 += "{:>10.5f}".format(EFFSIZELIQ[ii])
        else:
            RECORD_C1_3 += "{:>10.5f}".format(CWP/np.union1d(lay_liq, lay_ice).size)
            RECORD_C1_3 += "{:>10.5f}".format(FRACICE)
            RECORD_C1_3 += "{:>10.5f}".format(EFFSIZEICE)
            RECORD_C1_3 += "{:>10.5f}".format(EFFSIZELIQ)
        RECORD_C1_3 += "\n"
        ii += 1
    RECORD_C1_3 += "%"
    
    return RECORD_C1_1 + "\n" + RECORD_C1_3

def create_input_rrtmg_lw(solar_zenith_angle, lat=75., clouds=0, semiss=0.99):
    # Record 1.1
    
    CXID = "$ RRTM_LW runscript created on {}".format(dt.datetime.now())
    
    RECORD_1_1 = "{:80s}".format(CXID)
    
    #      RECORD 1.2
     
    #       IAER,    IATM,  IXSECT, NUMANGS,   IOUT,  IDRV,  IMCA, ICLD
     
    #         20,      50,      70,   84-85,  88-90,    92,    94,   95   
     
    #    18x, I2, 29X, I1, 19X, I1, 13X, I2, 2X, I3, 1X,I1,1X, I1,   I1
     
     
    # 	  IAER   (0,10)   flag for aerosols
    #                   = 0   no layers contain aerosols
    #                   = 10  one or more layers contain aerosols (only absorption is treated)
    #                        (requires the presence of file IN_AER_RRTM)
    if os.path.exists('IN_AER_RRTM_LW'):
        IAER = GLOBAL_AEROSOL
        subprocess.call(['cp', 'IN_AER_RRTM_LW', 'IN_AER_RRTM'])
    else:
        IAER = 0
    # 	  IATM   (0,1)   flag for RRTATM    1 = yes
    IATM = 1
    # 	  IXSECT (0,1) flag for cross-sections
    #                   = 0  no cross-sections included in calculation
    #                   = 1  cross-sections included in calculation
    IXSECT = 0
    #           NUMANGS = 0  radiance will be computed at 1 angle, the cosine of which
    #                        equals 1/1.66 (standard diffusivity angle approximation)
    #                        (default and only option available)
    NUMANGS = 0
    # 	  IOUT = -1 if no output is to be printed out.
    # 	       =  0 if the only output is for 10-3250 cm-1.
    # 	       =  n (n = 1-16) if the only output is from band n.
    # 		    For the wavenumbers for each band, see Table I.
    # 	       = 99 if output is generated for 17 spectral intervals, one
    # 		    for the full longwave spectrum (10-3250 cm-1), and one 
    # 		    for each of the 16 bands.
    IOUT = 0
    # 	  IDRV   (0,1) flag for applying optional adjustment to the upward flux at
    #                        each layer based on the derivative of the Planck function 
    #                        with respect to temperature for the change in surface 
    #                        temperature (DTBOUND) provided on record 1.4.1 relative to
    #                        the surface temperature (TBOUND) provided on record 1.4
    #                   = 0  standard forward calculation; do not apply derivative 
    #                        adjustment (default)
    #                   = 1  adjust upward flux at each layer based on derivative of 
    #                        the Planck function to account for the change in surface
    # 		       temperature defined by DTBOUND
    IDRV = 0
    # 	  IMCA   (0,1) flag for McICA (Monte Carlo Independent Column Approximation)
    #                        for statistical representation of sub-grid cloud fraction 
    #                        and cloud overlap
    #                   = 0  standard forward calculation; do not use McICA
    #                   = 1  use McICA (will perform statistical sample of 200 forward
    # 		       calculations and output average flux and heating rates)
    if clouds == 0:
        IMCA = 0
    else:
        IMCA = 1
    # 	  ICLD   (0,1,2,3,4,5) flag for clouds
    #                   = 0  no cloudy layers in atmosphere
    #                   = 1  one or more cloudy layers present in atmosphere.  Cloud layers
    # 		       are treated using a RANDOM overlap assmption.
    #                        (requires the presence of file IN_CLD_RRTM for column model)
    #                        (available for IMCA = 0 or 1)
    #                   = 2  one or more cloudy layers present in atmosphere.  Cloud layers
    # 		       are treated using a MAXIMUM/RANDOM overlap assmption.
    #                        (requires the presence of file IN_CLD_RRTM for column model)
    #                        (available for IMCA = 0 or 1)
    #                   = 3  one or more cloudy layers present in atmosphere.  Cloud layers
    # 		       are treated using a MAXIMUM overlap assmption.
    #                        (requires the presence of file IN_CLD_RRTM for column model)
    #                        (available only for IMCA = 1)
    #                   = 4  one or more cloudy layers present in atmosphere.  Cloud layers
    # 		       are treated using a EXPONENTIAL overlap assmption.
    #                        (requires the presence of file IN_CLD_RRTM for column model,
    #                        and inputs set on Records 1.5 and either 1.5.1 or 1.5.2)
    #                        (available only for IMCA = 1)
    #                   = 5  one or more cloudy layers present in atmosphere.  Cloud layers
    # 		       are treated using a EXPONENTIAL-RANDOM overlap assmption.
    #                        (requires the presence of file IN_CLD_RRTM for column model,
    #                        and inputs set on Records 1.5 and either 1.5.1 or 1.5.2)
    #                        (available only for IMCA = 1)
    ICLD = clouds
    
    RECORD_1_2  = 18 * " " + "{:2d}".format(IAER)
    RECORD_1_2 += 29 * " " + "{:1d}".format(IATM)
    RECORD_1_2 += 19 * " " + "{:1d}".format(IXSECT)
    RECORD_1_2 += 13 * " " + "{:2d}".format(NUMANGS)
    RECORD_1_2 += 2  * " " + "{:3d}".format(IOUT)
    RECORD_1_2 += 1  * " " + "{:1d}".format(IDRV)
    RECORD_1_2 += 1  * " " + "{:1d}".format(IMCA)
    RECORD_1_2 += 0  * " " + "{:1d}".format(ICLD)
    
    # RECORD 1.4  
  
    #TBOUND,  IEMIS, IREFLECT, (SEMISS(IB),IB=1,16)
 
    #      1-10,     12,       15,        16-95
 
    #     E10.3  1X, I1,   2X, I1,        16E5.3
 
 
    #     TBOUND   temperature at the surface.  If input value < 0, then surface temperature
    #              is set to the temperature at the bottom of the first layer (see Record 2.1.1)
    TBOUND = T_PROF[0]
    #     IEMIS  = 0 each band has surface emissivity equal to 1.0
    #            = 1 each band has the same surface emissivity (equal to SEMISS(16)) 
    #            = 2 each band has different surface emissivity (for band IB, equal to SEMISS(IB))
    IEMIS = 1

    #     IREFLECT = 0 for Lambertian reflection at surface, i.e. reflected radiance 
    #		is equal at all angles
    #              = 1 for specular reflection at surface, i.e. reflected radiance at angle
	#		is equal to downward surface radiance at same angle multiplied by
	#		the reflectance.  THIS OPTION CURRENTLY NOT IMPLEMENTED.
    IREFLECT = 0
    #     SEMISS   the surface emissivity for each band (see Table I).  All values must be 
    #              greater than 0 and less than or equal to 1.  If IEMIS = 1, only
    #              the first value of SEMISS (SEMISS(16)) is considered.  If IEMIS = 2 
    #              and no surface emissivity value is given for SEMISS(IB), a value of 1.0 
    #              is used for band IB.
    SEMISS = [semiss]
    RECORD_1_4  = "{:>10.3f}".format(TBOUND) 
    RECORD_1_4 += 1  * " " + "{:1d}".format(IEMIS)
    RECORD_1_4 += 2  * " " + "{:1d}".format(IREFLECT)
    for element in SEMISS:
        RECORD_1_4 += "{:>5.3f}".format(element)
        
    # ****************************************************************************
    #********     these records applicable if RRTATM selected (IATM=1)    ********
 
    #RECORD 3.1
 
 
    #  MODEL,   IBMAX,  NOPRNT,  NMOL, IPUNCH,   MUNITS,    RE,      CO2MX
 
    #      5,      15,      25,    30,     35,    39-40, 41-50,      71-80

    #     I5,  5X, I5,  5X, I5,    I5,     I5,   3X, I2, F10.3, 20X, F10.3
 
 
    #       MODEL   selects atmospheric profile
 
    #                 = 0  user supplied atmospheric profile
    #                 = 1  tropical model
    #                 = 2  midlatitude summer model
    #                 = 3  midlatitude winter model
    #                 = 4  subarctic summer model
    #                 = 5  subarctic winter model
    #                 = 6  U.S. standard 1976
    MODEL = 0
 
    #       IBMAX     selects layering for RRTM
 
    #                 = 0  RRTM layers are generated internally (default)
    #                 > 0  IBMAX is the number of layer boundaries read in on Record 3.3B which are
    #                             used to define the layers used in RRTM calculation
    IBMAX = len(HEIGHT_PROF)
    #       NOPRNT    = 0  full printout
    #                 = 1  selects short printout
    NOPRINT = 0
    #       NMOL      number of molecular species (default = 7; maximum value is 35)
    NMOL = 7
    #       IPUNCH    = 0  layer data not written (default)
    #                 = 1  layer data written to unit IPU (TAPE7)
    IPUNCH = 1
    #       MUNITS    = 0  write molecular column amounts to TAPE7 (if IPUNCH = 1, default)
    #                 = 1  write molecular mixing ratios to TAPE7 (if IPUNCH = 1)
    MUNITS = 1
    #       RE        radius of earth (km)
	#                defaults for RE=0: 
    #    	        a)  MODEL 0,2,3,6    RE = 6371.23 km
    #			b)        1          RE = 6378.39 km
	#		c)        4,5        RE = 6356.91 km
    RE = 0

    RECORD_3_1  = "{:5d}".format(MODEL)
    RECORD_3_1 += 5 * " " + "{:5d}".format(IBMAX) 
    RECORD_3_1 += 5 * " " + "{:5d}".format(NOPRINT)
    RECORD_3_1 += "{:5d}".format(NMOL)
    RECORD_3_1 += "{:5d}".format(IPUNCH)
    RECORD_3_1 += 3 * " " + "{:2d}".format(MUNITS)
    RECORD_3_1 += "{:10.3f}".format(RE)

    #   RECORD 3.2
 
 
    #     HBOUND,   HTOA
 
    #       1-10,  11-20
 
    #      F10.3,  F10.3
  
 
    #      HBOUND     altitude of the surface (km)
    HBOUND = HEIGHT_PROF[0]
    
    #      HTOA       altitude of the top of the atmosphere (km)
    HTOA = HEIGHT_PROF[-1]
    
    RECORD_3_2 = "{:10.3f}{:10.3f}".format(HBOUND, HTOA)
    
    # RECORD 3.3B        For IBMAX > 0  (from RECORD 3.1)
 
    #            ZBND(I), I=1, IBMAX   altitudes of RRTM layer boundaries
 
    #           (8F10.3)

 	#            If IBMAX < 0 

	#	PBND(I), I=1, ABS(IBMAX) pressures of LBLRTM layer boundaries

    #           (8F10.3)
    
    ZBND = ""
    for ii in range(len(HEIGHT_PROF)):
    
            ZBND += "{:10.3f}".format(HEIGHT_PROF[ii])
            if ii % 8 == 7:
                ZBND += "\n"
    
    RECORD_3_3B = ZBND
    
    # RECORD 3.4
    
    #           IMMAX,   HMOD
 
    #           5,   6-29
 
    #          I5,    3A8
 
 
    #       IMMAX    number of atmospheric profile boundaries

    #                If IMMAX is set to a negative value, the level boundaries are
    #                specified in PRESSURE (mbars).
    IMMAX = len(HEIGHT_PROF)
    #       HMOD    24 character description of profile
    HMOD = ""
    
    # RECORD 3.5
 
 
    #   ZM,    PM,    TM,    JCHARP, JCHART,   (JCHAR(K),K =1,28)
 
    # 1-10, 11-20, 21-30,        36,     37,     41  through  68
 
    #E10.3, E10.3, E10.3,   5x,  A1,     A1,    3X,    28A1
 
 
    #      ZM       boundary altitude (km). If IMMAX < 0, altitude levels are 
	#	   computed from pressure levels PM. If any altitude levels are
	#	   provided, they are ignored if  IMMAX < 0 (exception: The
	#	   first input level must have an accompanying ZM for input
	#	   into the hydrostatic equation)
    ZM = HEIGHT_PROF
 
    #      PM       pressure (units and input options set by JCHARP)
    PM = PRESS_PROF
    
    #      TM       temperature (units and input options set by JCHART)
    TM = T_PROF
    
    #  JCHARP       flag for units and input options for pressure (see Table II)
    JCHARP = "A"
    #  JCHART       flag for units and input options for temperature (see Table II)
    JCHART = "A"
    #  JCHAR(K)     flag for units and input options for
    #               the K'th molecule (see Table II)
    #A -> ppmv, B -> cm-3, C -> g/kg, D -> g/m3 (so kann man retrievte Spurengase verwenden) H -> % (relative Humidity)
    # ( 1)  H2O  ( 2)  CO2  ( 3)    O3 ( 4)   N2O ( 5)    CO ( 6)   CH4 ( 7)    O2
    #with open("/home/phi.richter/Code/run_RRTMG/atmosphere", "r") as f:
    #    JCHAR = f.readline().rstrip()
    JCHAR = GLOBAL_ATM#"4444444"
    #JCHAR = "C555555"
     
    #RECORD 3.6.1 ... 3.6.N
 
    #      VMOL(K), K=1, NMOL
 
    #      8E10.3
 
    #      VMOL(K) density of the K'th molecule in units set by JCHAR(K)
    RECORD_3_5_6 = ""
    for loop in range(len(HEIGHT_PROF)):
        RECORD_3_5_6 += "{:10.3E}".format(ZM[loop])
        RECORD_3_5_6 += "{:10.3E}".format(PM[loop])
        RECORD_3_5_6 += "{:10.3f}".format(TM[loop])
        RECORD_3_5_6 += 5 * " " + "{:1s}".format(JCHARP) + "{:1s}".format(JCHART)
        RECORD_3_5_6 += 3 * " " + "{}".format(JCHAR)
        RECORD_3_5_6 += "\n"
        for molecules in range(7):
            RECORD_3_5_6 += "{:10.3E}".format(0.0)
        RECORD_3_5_6 += "\n"
    # REPEAT records 3.5 and 3.6.1 to 3.6.N for each of the remaining IMMAX boundaries
        
    RECORD_3_4 = "{:5d}".format(IMMAX) + "{:24s}".format(HMOD)
    return RECORD_1_1 + "\n" + RECORD_1_2 + "\n" + RECORD_1_4 + "\n" + \
            RECORD_3_1 + "\n" + RECORD_3_2 + "\n" + RECORD_3_3B + "\n" + RECORD_3_4 + "\n" + \
            RECORD_3_5_6


def create_input_rrtmg_sw(solar_zenith_angle, lat=75., clouds=0, albedo_dir=0.3, albedo_diff=0.3):
    # Record 1.1
    
    CXID = "$ RRTM_SW runscript created on {}".format(dt.datetime.now())
    
    RECORD_1_1 = "{:80s}".format(CXID)
    
    # RECORD 1.2
    # 
    #      IAER,    IATM,   ISCAT,  ISTRM,   IOUT,   ICLD,  IDELM, ICOS
    # 
    #        20,      50,      83,     85,  88-90,     95,     99,  100
    # 
    #   18x, I2, 29X, I1, 32X, I1, 1X, I1, 2X, I3, 4X, I1, 3X, I1,   I1
     
        
    
    #	  IAER   (0,10)   flag for aerosols
    #                  = 0   no layers contain aerosols
    #                  = 10  one or more layers contain aerosols
    #                       (requires the presence of file IN_AER_RRTM)
    if os.path.exists('IN_AER_RRTM_SW'):
        IAER = GLOBAL_AEROSOL#0
        subprocess.call(['cp', 'IN_AER_RRTM_SW', 'IN_AER_RRTM'])
    else:
        IAER = 0
    #	  IATM   (0,1)   flag for RRTATM    1 = yes
    IATM = 1
    
    #         ISCAT  (0,1) switch for DISORT or simple two-stream scattering 
    #                 = 0  DISORT (unavailable)
    #                 = 1  two-stream    (default)
    ISCAT = 1
    
    #          ISTRM   flag for number of streams used in DISORT  (ISCAT must be equal to 0)
    #                  = 0  - 4 streams (default)
    #                  = 1  - 8 streams
    #                  = 2  - 16 streams 
    ISTRM = 2
    
    #	  IOUT    = -1 if no output is to be printed out.
    #	          =  0 if the only output is for 820-50000 cm-1.
    #	          =  n (n = 16-29) if the only output is from band n.
    #		       For the wavenumbers for each band, see Table I.
    #	          = 98 if output is generated for 15 spectral intervals, one
    #		       for the full shortwave spectrum (820-50000 cm-1), and one 
    #		       for each of the 14 bands.
    IOUT = 0
    
    if clouds == 0:
        ICMA = 0
    else:
        ICMA = 1
    
    # 	  ICLD   (0,1) flag for clouds   (currently not implemented)
    #                  = 0  no cloudy layers in atmosphere
    #                  = 1  one or more cloudy layers present in atmosphere
    #                       (requires the presence of file IN_CLD_RRTM)
    ICLD = clouds
    
    #  Measurement comparison flags:
    #          IDELM  (0,1) flag for outputting downwelling fluxes computed using the delta-M scaling approximation
    #                  = 0  output "true" direct and diffuse downwelling fluxes
    #                  = 1  output direct and diffuse downwelling fluxes computed with delta-M approximation
    #                 (Note:  The delta-M approximation is always used internally in RRTM_SW to compute the total
    #                 downwelling flux at each level.  What the IDELM flag determines is whether the components 
    #                 of the downwelling flux, the direct and diffuse fluxes, that are output are the actual direct
    #                 and diffuse fluxes (IDELM = 0) or are those computed using the delta-M approximation (IDELM = 1).
    #                 If the computed direct and diffuse fluxes are being compared with corresponding measured fluxes 
    #                 and a nontrivial amount of forward scattered radiation is likely to have been included in the
    #                 measurement of the direct flux, then IDELM should be set to 1.)
    IDELM = 0#1
    
    #          ICOS   = 0 there is no need to account for instrumental cosine response
    #                 = 1 to account for instrumental cosine response in the computation of the direct and diffuse fluxes 
    #                 = 2 to account for instrumental cosine response in the computation of the diffuse fluxes only
    #                 (Note:  ICOS = 1 and ICOS = 2 requires the presence of the file COSINE_RESPONSE, which should 
    #                 consist of lines containing pairs of numbers (ANG, COSFAC), where COSFAC is the instrumental cosine
    #                 response at the angle ANG.) 
    ICOS = 0
    
    RECORD_1_2  = 18 * " " + "{:2d}".format(IAER)
    RECORD_1_2 += 29 * " " + "{:1d}".format(IATM)
    RECORD_1_2 += 32 * " " + "{:1d}".format(ISCAT)
    RECORD_1_2 += 1  * " " + " "#"{:1d}".format(ISTRM)
    RECORD_1_2 += 2  * " " + "{:3d}".format(IOUT)
    RECORD_1_2 += 3  * " " + "{:1d}".format(ICMA)
    RECORD_1_2 += 0  * " " + "{:1d}".format(ICLD)
    RECORD_1_2 += 3  * " " + "{:1d}".format(IDELM)
    RECORD_1_2 += "{:1d}".format(ICOS)
                       
    # RECORD 1.2.1  

    #       JULDAT,      SZA, ISOLVAR,   SCON, SOLCYCFRAC, (SOLVAR(IB),IB=16,29)

    #        13-15,    19-25,   29-30,  31-40,      41-50,   51-190

    #    12X,   I3, 3X, F7.4,  3X, I2,  F10.4,      F10.5,  14F10.5

	
    #    JULDAT       Julian day associated with calculation (1-365/366 starting January 1).
	#             Used to calculate Earth distance from sun. A value of 0 (default) indicates 
	#             no scaling of solar source function using earth-sun distance.
    JULDAT = 150
    #    SZA          Solar zenith angle in degrees (0 degrees is overhead).

    SZA = solar_zenith_angle
    #    ISOLVAR      Solar variability option [-1,0,1,2,3]

	#	     =-1 (when SCON .EQ. 0.0): no solar variability; each band uses the Kurucz 
    #                     extraterrestrial solar irradiance, corresponding to a spectrally integrated 
    #                     solar constant of 1368.22 Wm-2 (method used in rrtmg_sw_v3.91 and earlier)
    #                 =-1 (when SCON .NE. 0.0): solar variability active; baseline solar irradiance
    #                     of 1368.22 Wm-2 is scaled to SCON, solar variability is determined (optional)
    #                     by non-zero scale factors for each band defined by SOLVAR

	#	     = 0 (when SCON .EQ. 0.0): no solar variability; each band uses the solar constant 
    #                     from the NRLSSI2 model of 1360.85 Wm-2 (for the spectral range 100-50000 cm-1) 
    #                     with quiet sun, facular and sunspot contributions fixed to the mean of 
    #                     Solar Cycles 13-24 and averaged over the mean solar cycle
	#	     = 0 (when SCON .NE. 0.0): no solar variability; baseline solar irradiance of
    #                     1360.85 Wm-2 (for the spectral range 100-50000 cm-1) is scaled to SCON

	#	     = 1 solar variability active; solar cycle contribution determined by input of
    #                     SOLCYCFRAC, a fraction representing the phase of the solar cycle, with 
    #                     facular brightening and sunspot blocking effects varying in time with this
    #                     fraction through their mean variations over the average of Solar Cycles 13-24
    #                     (corresponding to a solar constant of 1360.85 Wm-2); two amplitude scale 
    #                     factors provided in SOLVAR allow independent adjustment of facular and sunspot 
    #                     effects from their mean solar cycle amplitudes

	#	     = 2 solar variability active; solar cycle contribution determined by direct
	# 	         specification of Mg (facular) and SB (sunspot) indices consistent with the
    #                     NRLSSI2 solar model; these are provided in SOLVAR and are used to model the 
    #                     solar variability at a specific time for a specific solar cycle 
    #                     (SCON = 0.0 only; solar constant depends on Mg and SB indices provided)
    #                     Further information on setting the Mg and SB indices for this option can 
    #                     be found at the NRLSSI model github site: https://github.com/lasp/nrlssi.

	#	     = 3 (when SCON .EQ. 0.0): no solar variability; each band uses the NRLSSI2
    #                     extraterrestrial solar irradiance, corresponding to a spectrally integrated 
    #                     solar constant of 1360.85 Wm-2 with quiet sun, facular and sunspot
    #                     contributions averaged over the mean of Solar Cycles 13-24
    #                 = 3 (when SCON .NE. 0.0): solar variability active; baseline solar irradiance
    #                     of 1360.85 Wm-2 is scaled to SCON, solar variability is determined (optional)
    #                     by non-zero scale factors for each band defined by SOLVAR and applied to SCON
    ISOLVAR = 0#-1
    #    SCON         For ISOLVAR = -1 or 0:
    #                     Total solar irradiance (if SCON > 0, internal solar irradiance is scaled 
    #                     to this value)
    #                 For ISOLVAR = 1:
    #                     Solar constant; integral of total solar irradiance averaged over solar cycle
    #                     (if SCON > 0, internal solar irradiance is scaled to this value)
    #                 For ISOLVAR = 2:
    #                     SCON must be 0.0, since total solar irradiance is defined by the Mg and SB
    #                     indices provided in SOLVAR
    #                 For ISOLVAR = 3:
    #                     Total solar irradiance before individual band scale factors are applied
    #                     (if SCON > 0 internal solar irradiance is scaled to this value)
    #                 Set SCON = 0.0 to use internal solar irradiance, which depends on ISOLVAR
    SCON = 1370#0
    #    SOLCYCFRAC   Solar cycle fraction (0-1); fraction of the way through the mean 11-year
    #                 cycle with 0.0 defined as the first day of year 1 and 1.0 defined as the
    #                 last day of year 11 (ISOLVAR=1 only). Note that for the combined effect of
    #                 the solar constant of 1360.85, and the mean facular brightening and sunspot 
    #                 dimming components (without scaling), the minimum total solar irradiance of
    #                 1360.49 occurs at SOLCYCFRAC = 0.0265, and the maximum total solar irradiance 
    #                 of 1361.34 occurs at SOLCYCFRAC = 0.3826. 
    SOLCYCFRAC = 0
	#SOLVAR       Solar variability scaling factors or indices (ISOLVAR=-1,1,2,3 only)
	#             For ISOLVAR = 1:
    #                   SOLVAR(1)    Facular (Mg) index amplitude scale factor
    #                   SOLVAR(2)    Sunspot (SB) index amplitude scale factor

	#             For ISOLVAR = 2:
    #                   SOLVAR(1)    Facular (Mg) index as defined in the NRLSSI2 model;
    #                                used for modeling time-specific solar activity
    #                   SOLVAR(2)    Sunspot (SB) index as defined in the NRLSSI2 model; 
    #                                used for modeling time-specific solar activity

	#             For ISOLVAR = -1 or 3:
    #                   SOLVAR(1:14) Band scale factors for modeling spectral variation of 
    #                                averaged solar cycle in each shortwave band
    SOLVAR = [1,1]#0
    RECORD_1_2_1  = 12 * " " + "{:3d}".format(JULDAT)
    RECORD_1_2_1 += 3  * " " + "{:7.4f}".format(SZA)
    RECORD_1_2_1 += 3  * " " + "{:2d}".format(ISOLVAR)
    RECORD_1_2_1 += "{:10.4f}".format(SCON)
    RECORD_1_2_1 += "{:10.5f}".format(SOLCYCFRAC)
    #if ISOLVAR == -1 or ISOLVAR == 3:
    #    for ii in range(14):
    #        RECORD_1_2_1 += "{:5.3f}".format(SOLVAR[ii])
    #else:
    #    for ii in range(2):
    #        RECORD_1_2_1 += "{:5.3f}".format(SOLVAR[ii])
            
    # RECORD 1.4  
  
    #       IEMIS, IREFLECT, (SEMISS(IB),IB=16,29)
 
    #          12,       15,                 16-85
 
    #     11X, I1,   2X, I1,                14F5.3
 
    #    (Note:  surface reflectance = 1 - surface emissivity) 

    #     IEMIS  = 0 each band has surface emissivity equal to 1.0
    #            = 1 each band has the same surface emissivity (equal to SEMISS(16)) 
    #            = 2 each band has different surface emissivity (for band IB, equal to SEMISS(IB))
    IEMIS = 1

    #     IREFLECT = 0 for Lambertian reflection at surface, i.e. reflected radiance 
    #		is equal at all angles
    #              = 1 for specular reflection at surface, i.e. reflected radiance at angle
	#		is equal to downward surface radiance at same angle multiplied by
	#		the reflectance.  THIS OPTION CURRENTLY NOT IMPLEMENTED.
    IREFLECT = 0
    #     SEMISS   the surface emissivity for each band (see Table I).  All values must be 
    #              greater than 0 and less than or equal to 1.  If IEMIS = 1, only
    #              the first value of SEMISS (SEMISS(16)) is considered.  If IEMIS = 2 
    #              and no surface emissivity value is given for SEMISS(IB), a value of 1.0 
    #              is used for band IB.
    #SEMISS_DIF = [1-albedo_dir]#[0.8]
    SEMISS_DIR = [GLOBAL_ALB]#[1-albedo_diff]
    
    RECORD_1_4  = 11 * " " + "{:1d}".format(IEMIS)
    RECORD_1_4 += 2  * " " + "{:1d}".format(IREFLECT)
    for element in SEMISS_DIR:
        RECORD_1_4 += "{:5.3f}".format(element)
    #RECORD_1_4 += "\n"
    #RECORD_1_4 +=15*' '
    #for element in SEMISS_DIF:
    #    RECORD_1_4 += "{:5.3f}".format(element)
        
    # ****************************************************************************
    #********     these records applicable if RRTATM selected (IATM=1)    ********
 
    #RECORD 3.1
 
 
    #  MODEL,   IBMAX,  NOPRNT,  NMOL, IPUNCH,   MUNITS,    RE,      CO2MX, REF_LAT
 
    #      5,      15,      25,    30,     35,    39-40, 41-50,      71-80, 81-90

    #     I5,  5X, I5,  5X, I5,    I5,     I5,   3X, I2, F10.3, 20X, F10.3, F10.3
 
 
    #       MODEL   selects atmospheric profile
 
    #                 = 0  user supplied atmospheric profile
    #                 = 1  tropical model
    #                 = 2  midlatitude summer model
    #                 = 3  midlatitude winter model
    #                 = 4  subarctic summer model
    #                 = 5  subarctic winter model
    #                 = 6  U.S. standard 1976
    MODEL = 0
 
    #       IBMAX     selects layering for RRTM
 
    #                 = 0  RRTM layers are generated internally (default)
    #                 > 0  IBMAX is the number of layer boundaries read in on Record 3.3B which are
    #                             used to define the layers used in RRTM calculation
    IBMAX = len(HEIGHT_PROF)
    #       NOPRNT    = 0  full printout
    #                 = 1  selects short printout
    NOPRINT = 0
    #       NMOL      number of molecular species (default = 7; maximum value is 35)
    NMOL = 7
    #       IPUNCH    = 0  layer data not written (default)
    #                 = 1  layer data written to unit IPU (TAPE7)
    IPUNCH = 1
    #       MUNITS    = 0  write molecular column amounts to TAPE7 (if IPUNCH = 1, default)
    #                 = 1  write molecular mixing ratios to TAPE7 (if IPUNCH = 1)
    MUNITS = 1
    #       RE        radius of earth (km)
	#                defaults for RE=0: 
    #    	        a)  MODEL 0,2,3,6    RE = 6371.23 km
    #			b)        1          RE = 6378.39 km
	#		c)        4,5        RE = 6356.91 km
    RE = 0
    #       CO2MX     mixing ratio for CO2 (ppm).  Default is 330 ppm.
    CO2MX = 400
	# REF_LAT     latitude of location of calculation (degrees)
	#	     defaults for REF_LAT = 0:
	#	     a) MODEL 0,2,3,6    REF_LAT = 45.0 degrees
	#	     b) MODEL 1          REF_LAT = 15.0
	#	     c) MODEL 4,5        REF_LAT = 60.0
    REF_LAT = 0
    
    RECORD_3_1  = "{:5d}".format(MODEL)
    RECORD_3_1 += 5 * " " + "{:5d}".format(IBMAX) 
    RECORD_3_1 += 5 * " " + "{:5d}".format(NOPRINT)
    RECORD_3_1 += "{:5d}".format(NMOL)
    RECORD_3_1 += "{:5d}".format(IPUNCH)
    RECORD_3_1 += 3 * " " + "{:2d}".format(MUNITS)
    RECORD_3_1 += "{:10.3f}".format(RE)
    RECORD_3_1 += 20 * " " + "{:10.3f}".format(CO2MX)
    RECORD_3_1 += "{:10.3f}".format(REF_LAT)
    

    #   RECORD 3.2
 
 
    #     HBOUND,   HTOA
 
    #       1-10,  11-20
 
    #      F10.3,  F10.3
  
 
    #      HBOUND     altitude of the surface (km)
    HBOUND = HEIGHT_PROF[0]
    
    #      HTOA       altitude of the top of the atmosphere (km)
    HTOA = HEIGHT_PROF[-1]
    
    RECORD_3_2 = "{:10.3f}{:10.3f}".format(HBOUND, HTOA)
    
    # RECORD 3.3B        For IBMAX > 0  (from RECORD 3.1)
 
    #            ZBND(I), I=1, IBMAX   altitudes of RRTM layer boundaries
 
    #           (8F10.3)

 	#            If IBMAX < 0 

	#	PBND(I), I=1, ABS(IBMAX) pressures of LBLRTM layer boundaries

    #           (8F10.3)
    
    ZBND = ""
    for ii in range(len(HEIGHT_PROF)):
    
            ZBND += "{:10.3f}".format(HEIGHT_PROF[ii])
            if ii % 8 == 7:
                ZBND += "\n"
    
    RECORD_3_3B = ZBND
    
    # RECORD 3.4
    
    #           IMMAX,   HMOD
 
    #           5,   6-29
 
    #          I5,    3A8
 
 
    #       IMMAX    number of atmospheric profile boundaries

    #                If IMMAX is set to a negative value, the level boundaries are
    #                specified in PRESSURE (mbars).
    IMMAX = len(HEIGHT_PROF)
    #       HMOD    24 character description of profile
    HMOD = ""
    
    # RECORD 3.5
 
 
    #   ZM,    PM,    TM,    JCHARP, JCHART,   (JCHAR(K),K =1,28)
 
    # 1-10, 11-20, 21-30,        36,     37,     41  through  68
 
    #E10.3, E10.3, E10.3,   5x,  A1,     A1,    3X,    28A1
 
 
    #      ZM       boundary altitude (km). If IMMAX < 0, altitude levels are 
	#	   computed from pressure levels PM. If any altitude levels are
	#	   provided, they are ignored if  IMMAX < 0 (exception: The
	#	   first input level must have an accompanying ZM for input
	#	   into the hydrostatic equation)
    ZM = HEIGHT_PROF
 
    #      PM       pressure (units and input options set by JCHARP)
    PM = PRESS_PROF
    
    #      TM       temperature (units and input options set by JCHART)
    TM = T_PROF
    
    #  JCHARP       flag for units and input options for pressure (see Table II)
    JCHARP = "A"
    #  JCHART       flag for units and input options for temperature (see Table II)
    JCHART = "A"
    #  JCHAR(K)     flag for units and input options for
    #               the K'th molecule (see Table II)
    #A -> ppmv, B -> cm-3, C -> g/kg, D -> g/m3 (so kann man retrievte Spurengase verwenden) H -> % (relative Humidity)
    # ( 1)  H2O  ( 2)  CO2  ( 3)    O3 ( 4)   N2O ( 5)    CO ( 6)   CH4 ( 7)    O2
    #with open("/home/phi.richter/Code/run_RRTMG/atmosphere", "r") as f:
    #    JCHAR = f.readline().rstrip()
    JCHAR = GLOBAL_ATM#"111111"#"4444444"
    #JCHAR = "C555555"
     
    #RECORD 3.6.1 ... 3.6.N
 
    #      VMOL(K), K=1, NMOL
 
    #      8E10.3
 
    #      VMOL(K) density of the K'th molecule in units set by JCHAR(K)
    RECORD_3_5_6 = ""
    for loop in range(len(HEIGHT_PROF)):
        RECORD_3_5_6 += "{:10.3E}".format(ZM[loop])
        RECORD_3_5_6 += "{:10.3E}".format(PM[loop])
        RECORD_3_5_6 += "{:10.3f}".format(TM[loop])
        RECORD_3_5_6 += 5 * " " + "{:1s}".format(JCHARP) + "{:1s}".format(JCHART)
        RECORD_3_5_6 += 3 * " " + "{}".format(JCHAR)
        RECORD_3_5_6 += "\n"
        for molecules in range(7):
            RECORD_3_5_6 += "{:10.3E}".format(0.0)
        RECORD_3_5_6 += "\n"
    # REPEAT records 3.5 and 3.6.1 to 3.6.N for each of the remaining IMMAX boundaries
        
    RECORD_3_4 = "{:5d}".format(IMMAX) + "{:24s}".format(HMOD)
    return RECORD_1_1 + "\n" + RECORD_1_2 + "\n" + RECORD_1_2_1 + "\n" + RECORD_1_4 + "\n" + \
            RECORD_3_1 + "\n" + RECORD_3_2 + "\n" + RECORD_3_3B + "\n" + RECORD_3_4 + "\n" + \
            RECORD_3_5_6


def read_results(layer, spec_range, keys, fname="OUTPUT_RRTM"):
    '''
    Read output files of RRTMG and save all data corresponding to the keys KEYS_SW and keys_LW
    '''
    with open(fname, "r") as f:
        cont = f.readlines()
        
    header = []
    for line in cont:
        #print(line)
        
        ## find header
        if "LEVEL" in line:
            for element in line.split("  "):
                if len(element) > 0:
                    if element.rstrip().lstrip() == "LEVEL PRESSURE":
                        text = "LEVEL"
                        header.append(text)
                        text = "PRESSURE"
                        header.append(text)
                    else:
                        text = element.rstrip().lstrip()
                        header.append(text)
                        
     
    for ii in range(len(cont)):
        if "LEVEL" in cont[ii]:
            start = ii+2
        if " 0 " in cont[ii]:
            end = ii+1


    col = [[] for ii in range(len(header))]

    for line in cont[start:end]:
        ii = 0
        for element in line.split(" "):
            if len(element) > 0:
                if "*" in element:
                    col[ii].append(0)
                else:
                    col[ii].append(float(element))
                ii += 1
    col = np.array(col)
    out = dict()
    for key in range(len(header)):
        out.update({header[key]: col[key, :]})
    out = pd.DataFrame(out)
    return out

def RRTMG(sza, albedo_dir, albedo_diff, cloud, cwp, rl, ri, wpi, semiss, clouds):
    '''
    Call RRTMG
    '''
    
    ret = create_input_rrtmg_sw(solar_zenith_angle=sza, \
                           clouds=clouds, \
                           albedo_dir=albedo_dir, \
                               albedo_diff=albedo_diff)
    if clouds != 0:
        cld = create_cloud_rrtmg(lay_liq=cloud, lay_ice=cloud, cwp=cwp, rliq=rl, rice=ri, fice=wpi, homogenous=False, clt=np.ones(len(cloud)))
        with open("IN_CLD_RRTM", "w") as f:
            f.write(cld)
    with open("INPUT_RRTM", "w") as f:
        f.write(ret)
        

    subprocess.call(['{}'.format(SRC_RRTMG_SW)])
    all_sw = read_results(len(HEIGHT_PROF), 'sw_sum', KEYS_SW)
    
    ret = create_input_rrtmg_lw(solar_zenith_angle=sza, \
                       clouds=clouds, \
                       semiss=semiss)
        
    with open("INPUT_RRTM", "w") as f:
        f.write(ret)

    subprocess.call(['{}'.format(SRC_RRTMG_LW)])
    all_lw = read_results(len(HEIGHT_PROF), 'lw_sum', KEYS_LW)

    return all_sw, all_lw


def write_results(all_sw, all_lw, clear_sw, clear_lw, sza, cwp, wpi, rl, ri, cloud, fname):
    '''
    Write results of RRTMG calculation to netCDF4-File
    '''

    with nc.Dataset(fname, "w") as outfile:
        outfile.createDimension("const", 1)
        outfile.createDimension("level", clear_sw['LEVEL'].size)
        outfile.createDimension('cgrid', cloud.size)
        
        
        sza_out = outfile.createVariable("solar_zenith_angle", "f8", ("const", ))
        sza_out.units = "Deg"
        sza_out[:] = sza
    
        
        cloud_out = outfile.createVariable("cloud_idx", "i4", ("cgrid", ))
        cloud_out[:] = cloud

        cwp_out = outfile.createVariable("CWP", "f8", ("cgrid", ))
        cwp_out.units = "gm-2"
        cwp_out[:] = cwp
        
        rl_out = outfile.createVariable("rl", "f8", ("cgrid", ))
        rl_out.units = "um"
        rl_out[:] = rl
        

        ri_out = outfile.createVariable("ri", "f8", ("cgrid", ))
        ri_out.units = "um"
        ri_out[:] = ri
        wpi_out = outfile.createVariable("WPi", "f8", ("cgrid", ))
        wpi_out.units = "1"
        wpi_out[:] = wpi
                
        clear_sw_out = [None for ii in range(len(clear_sw.keys()))]
        all_sw_out = [None for ii in range(len(all_sw.keys()))]
        for ii in range(len(all_sw.keys())):
            if all_sw.keys()[ii] == "LEVEL" or all_sw.keys()[ii] == "PRESSURE":
                continue
            clear_sw_out[ii] = outfile.createVariable("clear_sw_{}".format(clear_sw.keys()[ii]), 'f8', ('level', ))
            all_sw_out[ii] = outfile.createVariable("all_sw_{}".format(all_sw.keys()[ii]), 'f8', ('level', ))

            if all_sw.keys()[ii] == "HEATING RATE":
                all_sw_out[ii].units = "degree/day"
                clear_sw_out[ii].units = "degree/day"

            else:
                all_sw_out[ii].units = "Wm-2"
                clear_sw_out[ii].units = "Wm-2"

            all_sw_out[ii][:] = np.array(all_sw[all_sw.keys()[ii]][::-1])
            clear_sw_out[ii][:] = np.array(clear_sw[clear_sw.keys()[ii]][::-1])
            
        clear_lw_out = [None for ii in range(len(clear_lw.keys()))]
        all_lw_out = [None for ii in range(len(all_lw.keys()))]
        for ii in range(len(all_lw.keys())):
            if all_lw.keys()[ii] == "LEVEL" or all_lw.keys()[ii] == "PRESSURE":
                continue
            clear_lw_out[ii] = outfile.createVariable("clear_lw_{}".format(clear_lw.keys()[ii]), 'f8', ('level', ))
            all_lw_out[ii] = outfile.createVariable("all_lw_{}".format(all_lw.keys()[ii]), 'f8', ('level', ))
            if all_lw.keys()[ii] == "HEATING RATE":
                all_lw_out[ii].units = "degree/day"
                clear_lw_out[ii].units = "degree/day"


            else:
                all_lw_out[ii].units = "Wm-2"
                clear_lw_out[ii].units = "Wm-2"


            all_lw_out[ii][:] = np.array(all_lw[all_lw.keys()[ii]][::-1])
            clear_lw_out[ii][:] = np.array(clear_lw[clear_lw.keys()[ii]][::-1])
            
        
def main(cloud, cwp, rl, ri, wpi, fname_out="out.nc"):
    '''
    Read input, call RRTMG and write results to file
    '''
    
    ## Perform clear sky calculation
    clear_sw, clear_lw = RRTMG(SZA, ALBEDO, ALBEDO, cloud, cwp, rl, ri, wpi, 0.99, 0)

    
    ## Perform all sky calculation
    all_sw, all_lw = RRTMG(SZA, ALBEDO, ALBEDO, cloud, cwp, rl, ri, wpi, 0.99, 2)

    ## Write results to netCDF4-File
    #write_results(all_sw, all_lw, clear_sw, clear_lw, SZA, cwp, wpi, rl, ri, cloud, fname_out)

    os.remove('TAPE6')
    os.remove('TAPE7')
    os.remove('tape6')
    os.remove('INPUT_RRTM')
    os.remove('IN_CLD_RRTM')
    os.remove('OUTPUT_RRTM')

    return [clear_sw['DOWNWARD FLUX'].iloc[-1], all_sw['DOWNWARD FLUX'].iloc[-1],\
        clear_lw['DOWNWARD FLUX'].iloc[-1], all_lw['DOWNWARD FLUX'].iloc[-1]], \
            [clear_sw['UPWARD FLUX'].iloc[-1], all_sw['UPWARD FLUX'].iloc[-1],\
        clear_lw['UPWARD FLUX'].iloc[-1], all_lw['UPWARD FLUX'].iloc[-1]]

if __name__ == '__main__':
    #global GLOBAL_ATM
    #global GLOBAL_AEROSOL
    #global GLOBAL_ALB

    GLOBAL_AEROSOL = 10
    GLOBAL_ALB = 0.6
    lay = np.array([5])
    cwp = np.array([20])
    rl = np.array([5.0])
    ri = np.array([40])
    wpi = np.array([0.5])
    downward, upward = main(lay, cwp, rl, ri, wpi)
    print(downward)
    print(upward)

    GLOBAL_AEROSOL = 0
    GLOBAL_ALB = 0.6
    lay = np.array([5])
    cwp = np.array([20])
    rl = np.array([5.0])
    ri = np.array([40])
    wpi = np.array([0.5])
    downward, upward = main(lay, cwp, rl, ri, wpi)
    print(downward)
    print(upward)

